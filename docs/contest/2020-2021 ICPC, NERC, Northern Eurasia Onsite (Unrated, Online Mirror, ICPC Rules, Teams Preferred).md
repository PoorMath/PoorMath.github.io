# [ 2020-2021 ICPC, NERC, Northern Eurasia Onsite (Unrated, Online Mirror, ICPC Rules, Teams Preferred)](https://codeforces.com/contest/1510)

| 排名   | 当场过题数 | 至今过题数 | 总题数 |
| ------ | ---------- | ---------- | ------ |
| 92/840 | 4          | 6          | 11     |

## **A**

**upsolved by **

### 题意



### 题解



## **B**

**upsolved by TYB**

### 题意

给出$n$个$d$位的$01$串密码，你开始时有一个$d$位全是$0$的串，每次操作可以选择将这个串某个位变为$1$，或者将全部位都变为$0$，求最少操作多少次，过程中得到的串包含了所有$n$个密码，并输出方案。

$d\le10,n<2^d$

### 题解

首先答案有上界：$\sum_i(popcount(S_i)+1)-1$，表示每个输入密码时都先清空一次（除了第一次不用清空），再逐位输入。考虑两个密码$S_a,S_b$，若$S_a\&S_b=S_a$，则在输入$S_b$的过程中可以顺便输入$S_a$​，也可以看作输入$S_a$​不需要代价。由此我们可以得到一个做法：将初始答案设为上界，若$S_a\&S_b=S_a$，则$S_a$向$S_b$连一条权值为$popcount(S_a)+1$的边，然后跑最大权匹配，初始答案减去最大权匹配即为答案。但这样点数$2^d\approx1000$，边数$3^d\approx60000$，费用流跑不动（但好像有优秀的模板可以跑过去）。注意到这张图的边权只和点有关，所以其实可以转化为最大匹配问题。具体来说，匈牙利算法寻找增广路的时候，会把这条路径上的边匹配情况全部取反，但是注意到，原来已经匹配了的点依然会匹配，也就是原来的边权并不会损失，所以只需要贪心地让$popcount$较大的点匹配即可。

复杂度$\mathcal{O}(6^d)$。

## **C**

**solved/upsolved by **

### 题意



### 题解



## **D**

**solved by TYB **

### 题意

给$n$个正整数，要求选出若干个数，使得他们乘积个位数为$d$​，且乘积最大，判断无解或输出方案。

$n\le10^5,1\le a_i\le10^9,d\le9$

### 题解

取对数DP即可。

## **E**

**solved by YZW**

### 题意



### 题解



## **F**

**solved/upsolved by **

### 题意



### 题解



## **G**

**solved by JLK**

### 题意



### 题解



## **H**

**solved/upsolved by **

### 题意



### 题解



## **I**

**upsolved by JLK**

### 题意



### 题解



## **J**

**solved/upsolved by **

### 题意



### 题解



## **K**

**solved by YZW**

### 题意



### 题解



## **记录**

YZW过K(0:13)。

TYB和JLK讨论D，想到了取对数，担心精度问题，但没有更好的想法，试了一下过了(0:32)。

JLK写G，但是发现不会输出方案。TYB给了一个假做法，发现假了又给了个真做法，写完也过了(1:26)。

然后YZW想到了E的DP，讨论后开始写。

写完第一发RE了(2:50)，发现式子推错了。

又讨论了一下，还是可做，又WA了2发后过了(4:22)。

期间TYB和JLK主要在看B、I，但都不会。

TYB最后写了几发J的乱搞，寄了。

## **总结**

TYB：B想了太久了，应该早点扔了。

## **Dirt**

E(-3)

