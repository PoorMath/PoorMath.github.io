# [比赛名称](https://codeforc.es/)

| 排名                | 当场过题数 | 至今过题数 | 总题数 |
| ------------------- | ---------- | ---------- | ------ |
| 45/1292（校内4/22） | 7          | 9          | 10      |

## **A**

**upsolved by **

### 题意



### 题解



## **B**

**solved by YZW&TYB**

### 题意

给出$a,b,c,n$，构造三个长度为$n$的字符串$s_1,s_2,s_3$，满足$lcs(s_1,s_2)=a,lcs(s_2,s_3)=b,lcs(s_1,s_3)=c$。$lcs$表示最长公共子序列。

$a,b,c,n\le 1000$

### 题解

不妨假设$a\le b\le c$，那么可以：三个串的$[1,a]$填一种，第二和第三个串的$[a+1,b]$填一种，第三个串的$[b+1,b+c-a]$和第一个串的$[b+1,b+c-a]$填一种，剩下的位置填其它字符，使得$lcs$不会再增加。

## **C**

**solved by JLK&TYB**

### 题意



### 题解



## **D**

**upsolved by TYB**

### 题意

给一棵$n$个节点的树，删$k$条边后再加$k$条边使得它还是一棵树，求方案数。

$n\le 5\times10^4,k\le\min(100,n-1)$

### 题解

考虑删掉$k$条边后，重新把它们连成树的方案数为：$n^{k-2}\Pi_{i=1}^{k+1}size_i$。推导过程见[prufer序列学习笔记]([prufer序列学习笔记 - Poor_Math-Wiki (poormath.github.io)](https://poormath.github.io/TYB/prufer序列学习笔记/))。

所以只需要考虑后面一坨怎么算。

考虑其意义，相当于把原树分成$k+1$个连通块后，从每个连通块选出一个点的方案数。树形DP，$f_{i,j,0/1}$表示以$i$为根的子树，分成$j$个连通块，$i$所在连通块是否选点的方案数。这是一个经典的树形背包问题，注意加上$size$和$k$的限制后其复杂度是$O(nk)$而不是$O(nk^2)$。

## **E**

**solved by JLK**

### 题意

有一棵$n$个点的树，每个点有权值$w_i$。现在只给出每个点的权值区间$[l_i,r_i]$，以及每条边两端的点权异或和，求有多少种赋值方案。

$1 \le n \le 10^5,0 \le l_i \le r_i \lt 2^{30},0 \le w_u \oplus w_v \lt 2^{30}$

### 题解

首先可以固定1为根，然后得到每个点$x$到根路径的异或和$S_x$，就可以得到每个$w_1\oplus S_x$的范围。由于是异或，可以按位考虑。先处理$w_1 \oplus S_x \le R$的情况。从大到小考虑，如果有一位$R$是0，那么$w_1 \oplus S_x$也必须是0。否则，$w_1\oplus S_x$这一位为0的情况全部都合法，为1的情况则需要看下一位。

这样就把限制条件转化为最多30个​​​不相交的区间。

那么大于的情况可以看做是上面的区间挖掉$w_1 \oplus S_x \le L-1$的区间。可以给前者一个1的权值，后者一个-1的权值来判断。因为后者一定是前者的子集。如果覆盖某个数权值和为$n$，说明满足全部$n$个限制条件，这个数就可以被记入答案。

直接把所有区间拉出来排序然后记录就可以通过。不过考虑到每个区间实际上对应着Trie树上的一个点，只需要对Trie树动态开点，对每个区间打标记，最后遍历一次统计即可。具体就是能够往下走的时候就往下走，记入统计的点必须至少有一个儿子为空，否则不能保证一定合法（因为子树内可能有-1的权值）。

$O(nlogw)$

## **F**

**solved by JLK**

### 题意

给定一个$n$个点$m$条边的无向图，两人博弈，每次可以删掉一条边或者删掉一个没有环的连通块。不能操作者输。问谁赢。

$1 \le n \le 100,0 \le m \le \min\{200,n(n-1)/2\}$

### 题解

删掉一条边，边数-1。

删掉一棵树，点数-k，边数-(k-1)，每次操作使点数+边数的奇偶性变化。

故只需判断n+m的奇偶性，奇数先手赢，偶数后手赢。

## **G**

**solved by JLK&TYB**

### 题意

给定$n,k,D$，求$a_i\ge 0,\sum\limits_{i=1}^na_i=D$条件下$\frac{D!}{\prod_{i=1}^n(a_i+k)!}$​。

$1 \le n \le 50,0 \le k \le 50,0 \le D \le 10^8$

### 题解

$\frac{D!}{\prod_{i=1}^n(a_i+k)!}$

$=\frac{(D+nk)!}{\prod_{i=1}^n(a_i+k)!}\frac{D!}{(D+nk)!}$

注意到$\sum_{b_i\ge0,\sum\limits_{i=1}^n b_i=P}\frac{P!}{\prod_{i=1}^nb_i!}=n^P$（可以考虑组合意义）​

那么令$b_i=a_i+k,P=D+nk$，只需求出$b_i\ge k$的方案即可。

这可以用容斥解决。

递推出$d_{i,j}$表示有$i$个数小于$k$，且他们的和为$j$的方案数（内部有排序）。

那么答案就是$\sum\limits_{i=0}^n (-1)^i\sum\limits_{j=0}^{i(k-1)}d_{i,j}C_n^iC_{D+nk}^j(n-i)^{D+nk-j}$

$D$很大，但是$nk$很小，可以预处理出需要的数字。

$O(n^2K)$

## **H**

**upsolved by JLK**

### 题意

定义运算$\otimes $，令$p_i$为第$i$个质数，若$x=\prod_i p_i^{a_i},y=\prod_i p_i^{a_i}$，则$x \otimes y=\prod_i p_i^{|a_i-b_i|}$。

$b_i=\sum_{1 \le j,k \le n,j \otimes k =i}a_jk^c$，求$b$。

$1 \le n \le 10^6,0 \le a_i \lt 998244353,0 \le c \le 10^9$

### 题解

不难发现$x\otimes y=\frac{lcm(x,y)}{gcd(x,y)}=\frac{xy}{gcd(x,y)^2}$

提取出gcd，$b_i=\sum\limits_{d=1}^i\sum\limits_{x=1}^{n/d}\sum\limits_{y=1}^{n/d}[gcd(x,y)=1,xy=i]a_{dx}(dy)^c$​

注意到枚举$x,y,xy\le n$​的复杂度是$O(nlogn)$​​的，可以对上式调换顺序。

$b_i=\sum\limits_{x=1}^{i}\sum\limits_{y=1}^{i}[gcd(x,y)=1,xy=i]y^c\sum\limits_{d=1}^{\min\{\lfloor \frac nx\rfloor,\lfloor \frac ny\rfloor\}}a_{dx}d^c$

令$f_{x,i}=\sum\limits_{d=1}^ia_{dx}d^c(i \le \lfloor \frac nx\rfloor)$​​​，这个也可以$O(nlogn)$​求出。

那么$b_i=\sum\limits_{x=1}^{i}\sum\limits_{y=1}^{i}[gcd(x,y)=1,xy=i]y^c f_{x,\min\{\lfloor \frac nx\rfloor,\lfloor \frac ny\rfloor\}}$​​

只需枚举$x,y$，计算每个$b_i$即可。

$O(nlogn)$（还要带上求gcd的复杂度？）

## **I**

**solved by JLK&TYB**

### 题意

给一个长度$n$的排列，每个数可以不变或+1，求改变后的最小逆序对数。

$1 \le n \le 2\times 10^5$

### 题解

逆序对减少的唯一情况是$i$在$i+1$之后，然后$i$变成$i+1$，$i+1$不变。

那么只需要从小到大考虑，碰到满足条件的就变，然后固定后一位继续往后找。

如果从小到大枚举，当前能变却不变，一定是不优的。

以及开始需要算好一次总逆序对。

$O(nlogn)$

## **J**

**solved by YZW**

### 题意



### 题解



## **记录**

开局分别看FIJ，出了一点问题，45min后都过了。

然后TYB写C，WA一次后发现相同处理有问题，JLK改对了(1:18)。

JLK先开B，但是发现推错了，于是TYB和YZW推式子，JLK写E。

E WA+RE后AC(2:35)。

然后YZW过B(2:43)。

YZW写H，JLK和TYB看G，推了一会式子后G过了(3:34)。

YZW说题读错了，然后一起卡DH至结束。

## **总结**

JLK：数学题太多了，没有数理基础，需要补一补。这场罚时也有点多，比较简单的题还是需要谨慎一点。

## **Dirt**

C(-1)

E(-2)

F(-1)

G(-1)

J(-1)

